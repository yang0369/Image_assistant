import os
from typing import List, Literal, Tuple
from dotenv import load_dotenv
from util.custom_logger import CustomLogger
from openai import OpenAI
from openai.types.beta.threads.run import Run as RunType
from openai.types.beta.thread import Thread as ThreadType
from pathlib import Path
import yaml
import time
import re
import io
import http.client
from http.client import HTTPSConnection as ImgGenType
import json
import pprint
from dataclasses import dataclass

# load OpenAI credentials
load_dotenv()

# set logger
logger = CustomLogger()

# set paths
ROOT = Path(__file__).parents[1]
DATA = ROOT / "data"
SRC = ROOT / "src"


@dataclass
class Assistant:
    """
    Assistant class helps user to generate image based on excel file generated by Menti
    """
    TextGen: OpenAI = None
    ImgGen: ImgGenType = None
    TextGen_key: str = os.getenv("OPENAI_KEY", default="False")
    ImgGen_key: str = os.getenv("IMAGINE_TOKEN", default="False")
    timeout: int = 60
    sleep_interval: int = 5

    def __post_init__(self):
        print("1")
        # validate credentials
        if self.TextGen_key and self.ImgGen_key:
            logger.info("successfully loaded OpenAI key")
        else:
            if not self.TextGen_key:
                raise ValueError("no OpenAI key found")
            if not self.ImgGen_key:
                raise ValueError("no Imagine API key found")

        # get system prompt
        with open(SRC / "util" / 'template.yml', 'r') as file:
            template = yaml.safe_load(file)

        self.prompt = template["PROMPT"]

        # load in clients
        if not self.TextGen:
            # create client
            self.TextGen = OpenAI(
                default_headers={"OpenAI-Beta": "assistants=v2"},
                max_retries=1,
                api_key=self.TextGen_key)
            
        if not self.ImgGen:
            self.ImgGen = http.client.HTTPSConnection("cl.imagineapi.dev")
        
        logger.info("Assistant is ready to help")

    def wait_on_run(
            self,
            run: RunType, 
            thread: ThreadType) -> RunType:
        """ wait for all polling to be completed """
        while run.status == "queued" or run.status == "in_progress":
            run = self.TextGen.beta.threads.runs.retrieve(
                thread_id=thread.id,
                run_id=run.id,
            )
            time.sleep(0.5)
        return run
    
    def parse_code_snippet(
            self, 
            run: RunType, 
            thread: ThreadType) -> str:
        """get the code response

        Args:
            run (RunType): openAI run session
            thread (ThreadType): openAI thread 

        Returns:
            str: code snippet
        """
        # parse code logs
        run_steps = self.chat_assistant.beta.threads.runs.steps.list(
            thread_id=thread.id,
            run_id=run.id
        )

        code_snippet = []
        for itm in run_steps.data[::-1]:
            sd = itm.step_details
            if sd.type == "tool_calls":
                tool_call_detail = sd.tool_calls        
                code_snippet.append(tool_call_detail[0].code_interpreter.input) # Algoritm
                if len(tool_call_detail[0].code_interpreter.outputs) > 0:
                    code_snippet.append(tool_call_detail[0].code_interpreter.outputs[0].logs) # Output

        code_snippet = "\n".join(code_snippet)
        logger.info("code interpreter >>>")
        logger.info(code_snippet)
        
        return code_snippet

    def parse_text(self, thread: ThreadType) -> str:
        """get text response in thread level

        Args:
            thread (ThreadType): openAI thread 

        Returns:
            str: proposal
        """
        text = []
        messages = self.TextGen.beta.threads.messages.list(thread_id=thread.id)

        for m in messages:
            text.append(m.content[0].text.value)

        text = "\n".join(text)
        logger.info("proposal >>>")
        logger.info(text)

        return text

    @staticmethod
    def get_prompt(text: str) -> list[str]:
        """get the image generation prompt from the proposal

        Args:
            text (str): proposal

        Returns:
            list[str]: list of prompts
        """
        # Regex pattern to extract text between "/imagine" and "â€”ar 16:9"
        pattern = r"/imagine\s*(.*?)\s*â€”ar 16:9"

        # Finding all matches
        matches = re.findall(pattern, text)

        logger.info("image prompts >>>")
        logger.info(matches)

        return matches
    
    def generate_prompts(self, file: io.BufferedReader) -> Tuple[str, List[str]]:
        # prepare input file
        file = self.TextGen.files.create(
            file=file,
            purpose='assistants')
        
        # create chat assistant
        self.chat_assistant = self.TextGen.beta.assistants.create(
            name="Feedback Analysis Assistant ",
            instructions=self.prompt,
            model="gpt-4o",
            temperature=0.01,
            top_p=0.1,
            tools=[{"type": "code_interpreter"}],
            tool_resources={
                "code_interpreter": {
                "file_ids": [file.id]
                }
            }
            )
        
        logger.info("starting thread")

        # create thread
        thread = self.TextGen.beta.threads.create()

        # add message to thread
        self.TextGen.beta.threads.messages.create(
            thread_id=thread.id,
            role="user",
            content="start",
        )

        # create a run 
        run = self.TextGen.beta.threads.runs.create_and_poll(
            thread_id=thread.id,
            assistant_id=self.chat_assistant.id,
        )

        run = self.wait_on_run(run, thread)

        # get code
        code_return = self.parse_code_snippet(run, thread)

        # get proposal
        text_return = self.parse_text(thread)

        prompts = self.get_prompt(text_return)

        return code_return, prompts

    def generate_image(self, prompt: str):

        # prepare payload
        data = {
            "prompt": prompt
        }
        
        headers = {
            'Authorization': f"Bearer {self.ImgGen_key}", 
            'Content-Type': 'application/json'
        }

        prompt_response_data = self.send_request('POST', '/items/images/', data, headers) 
        
        start_time = time.time()

        while True:
            try:
                status, res = self.check_image_status(prompt_response_data, headers)
                
                if status:
                    return res
                
                if time.time() - start_time > self.timeout:
                    logger.error("timeout reached while waiting for image status.")
                    raise TimeoutError("timeout reached while waiting for image status.")
                
                logger.info("Image status not ready. Sleeping for %d seconds.", self.sleep_interval)
                time.sleep(self.sleep_interval)

            except Exception as e:
                self.logger.exception("An error occurred while checking image status: %s", str(e))
                raise
            
    # send data to imagine API
    def send_request(
            self, 
            method: Literal["POST", "GET"], 
            path: str, 
            body: dict = None, 
            headers: dict = {}):
        
        self.ImgGen.request(method, path, body=json.dumps(body) if body else None, headers=headers)
        response = self.ImgGen.getresponse()
        data = json.loads(response.read().decode('utf-8'))
        pprint.pp(data)
        self.ImgGen.close()

        return data
    
    # retrieve the generated images
    def check_image_status(
            self, 
            data,
            headers) -> tuple:
        
        response_data = self.send_request(
            'GET', 
            f"/items/images/{data['data']['id']}", 
            headers=headers)
        
        if response_data['data']['status'] in ['completed', 'failed']:
            logger.info('completed image details',)
            return (True, response_data['data'])
        else:
            print(f"image is not finished generation. Status: {response_data['data']['status']}")
            return (False, None)
        
    def generate(self, file: io.BufferedReader):

        code_return, prompts = self.generate_prompts(file)
        
        res = dict()
        for idx, p in enumerate(prompts):
            res[idx] = self.generate_image(p)

        return res