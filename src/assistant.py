"""
This script serves as the one-stop backend code for this App
"""
import dataclasses
import http.client
import io
import json
import os
import pprint
import re
import time
import yaml
from dataclasses import dataclass
from dotenv import load_dotenv
from http.client import HTTPSConnection as ImgGenType
from openai import OpenAI
from openai.types.beta.thread import Thread as ThreadType
from openai.types.beta.threads.run import Run as RunType
from pathlib import Path
from typing import List, Literal, Tuple, Dict, Union

from util.custom_logger import CustomLogger

# load OpenAI credentials
load_dotenv()

# set logger
logger = CustomLogger()

# set paths
ROOT = Path(__file__).parents[1]
DATA = ROOT / "data"
SRC = ROOT / "src"


@dataclass
class Assistant:
    """
    Assistant class helps user to generate image based on excel file generated by Menti
    """
    TextGen: OpenAI = None
    TextGen_key: str = os.getenv("OPENAI_KEY", default="False")
    ImgGen_key: str = os.getenv("IMAGINE_TOKEN", default="False")
    timeout: int = 180
    sleep_interval: int = 5

    def __post_init__(self):
        # validate credentials
        if self.TextGen_key and self.ImgGen_key:
            logger.info("successfully loaded OpenAI key")
        else:
            if not self.TextGen_key:
                raise ValueError("no OpenAI key found")
            if not self.ImgGen_key:
                raise ValueError("no Imagine API key found")

        # get system prompt
        with open(SRC / "util" / 'template.yml', 'r', encoding='utf-8') as file:
            template = yaml.safe_load(file)

        self.prompt = template["PROMPT"]

        # load in clients
        if not self.TextGen:
            # create client
            self.TextGen = OpenAI(
                default_headers={"OpenAI-Beta": "assistants=v2"},
                max_retries=1,
                api_key=self.TextGen_key)
            
        logger.info("Assistant is ready to help")

    def wait_on_run(
            self,
            run: RunType, 
            thread: ThreadType) -> RunType:
        """ wait for all polling to be completed """
        while run.status == "queued" or run.status == "in_progress":
            run = self.TextGen.beta.threads.runs.retrieve(
                thread_id=thread.id,
                run_id=run.id,
            )
            time.sleep(0.5)
        return run
    
    def parse_code_snippet(
            self, 
            run: RunType, 
            thread: ThreadType) -> str:
        """get the code response

        Args:
            run (RunType): openAI run session
            thread (ThreadType): openAI thread 

        Returns:
            str: code snippet
        """
        # parse code logs
        run_steps = self.TextGen.beta.threads.runs.steps.list(
            thread_id=thread.id,
            run_id=run.id
        )

        code_snippet = []
        for itm in run_steps.data[::-1]:
            sd = itm.step_details
            if sd.type == "tool_calls":
                tool_call_detail = sd.tool_calls        
                code_snippet.append(tool_call_detail[0].code_interpreter.input) # Algoritm
                if len(tool_call_detail[0].code_interpreter.outputs) > 0:
                    code_snippet.append(tool_call_detail[0].code_interpreter.outputs[0].logs) # Output

        code_snippet = "\n".join(code_snippet)
        logger.info("code interpreter >>>")
        logger.info(code_snippet)
        
        return code_snippet

    def parse_text(self, thread: ThreadType) -> str:
        """get text response in thread level

        Args:
            thread (ThreadType): openAI thread 

        Returns:
            str: proposal
        """
        text = []
        messages = self.TextGen.beta.threads.messages.list(thread_id=thread.id)

        for m in messages:
            text.append(m.content[0].text.value)

        text = "\n".join(text)
        logger.info("proposal >>>")
        logger.info(text)

        return text

    @staticmethod
    def get_prompt(text: str) -> list[str]:
        """get the image generation prompt from the proposal

        Args:
            text (str): proposal

        Returns:
            list[str]: list of prompts
        """
        # Regex pattern to extract text between "/imagine" and "—ar 16:9"
        pattern = r"/imagine\s*(.*?\s*—ar 16:9)"

        # Finding all matches
        matches = re.findall(pattern, text)

        logger.info("image prompts >>>")
        logger.info(matches)

        return matches
    
    def generate_prompts(self, file: io.BufferedReader) -> Tuple[str, str, List[str]]:
        # prepare input file
        file = self.TextGen.files.create(
            file=file,
            purpose='assistants')
        
        logger.info("loaded file")
        # create chat assistant
        self.chat_assistant = self.TextGen.beta.assistants.create(
            name="Feedback Analysis Assistant ",
            instructions=self.prompt,
            model="gpt-4o",
            temperature=0.01,
            top_p=0.1,
            tools=[{"type": "code_interpreter"}],
            tool_resources={
                "code_interpreter": {
                "file_ids": [file.id]
                }
            }
            )
        
        logger.info("starting thread")

        # create thread
        thread = self.TextGen.beta.threads.create()

        # add message to thread
        self.TextGen.beta.threads.messages.create(
            thread_id=thread.id,
            role="user",
            content="start",
        )

        # create a run 
        run = self.TextGen.beta.threads.runs.create_and_poll(
            thread_id=thread.id,
            assistant_id=self.chat_assistant.id,
        )

        run = self.wait_on_run(run, thread)

        # get code
        code_return = self.parse_code_snippet(run, thread)

        # get proposal
        text_return = self.parse_text(thread)

        prompts = self.get_prompt(text_return)

        return code_return, text_return, prompts

    def generate_image(self, prompt: str) -> List[str]:
        """generate image links based on prompt

        Args:
            prompt (str): text instruction

        Raises:
            TimeoutError: time out

        Returns:
            List[str]: image links
        """

        # prepare payload
        data = {
            "prompt": prompt
        }
        
        logger.info(data)

        headers = {
            'Authorization': f"Bearer {self.ImgGen_key}", 
            'Content-Type': 'application/json'
        }
        # send prompt for image generation
        prompt_response_data = self.send_request('POST', '/items/images/', data, headers) 
        
        start_time = time.time()

        check_status = True
        while check_status:
            try:
                status, res = self.check_image_status(prompt_response_data, headers)
                
                if status:
                    return res.get("upscaled_urls", [])
                
                if time.time() - start_time > self.timeout:
                    logger.error("timeout reached while waiting for image status.")
                    check_status = False
                    raise TimeoutError("timeout reached while waiting for image status.")
                
                logger.info("Image status not ready. Sleeping for %d seconds.", self.sleep_interval)
                time.sleep(self.sleep_interval)

            except Exception as e:
                logger.exception("An error occurred while checking image status: %s", str(e))
            
    # send data to imagine API
    def send_request(
            self, 
            method: Literal["POST", "GET"], 
            path: str, 
            body: Union[Dict[str, str], None] = None, 
            headers: Dict[str, str] = {}) -> Dict:
        
        conn = http.client.HTTPSConnection("cl.imagineapi.dev")
        conn.request(method, path, body=json.dumps(body) if body else None, headers=headers)
        response = conn.getresponse()
        data = json.loads(response.read().decode('utf-8'))
        pprint.pp(data)
        conn.close()

        return data
    
    def check_image_status(
            self, 
            data: Dict[str, str],
            headers: Dict[str, str]) -> Tuple[bool, Union[Dict, None]]:
        """check if image link generation is completed or not

        Args:
            data (Dict[str, str]): response from post request
            headers (Dict[str, str]): request header

        Returns:
            Tuple[bool, Union[Dict, None]]: status and result
        """
        
        response_data = self.send_request(
            'GET', 
            f"/items/images/{data['data']['id']}", 
            headers=headers)
        
        if response_data['data']['status'] in ['completed', 'failed']:
            logger.info('completed image details',)
            return (True, response_data['data'])
        else:
            print(f"image is not finished generation. Status: {response_data['data']['status']}")
            return (False, None)
        
    def generate(self, file: io.BufferedReader) -> Dict[int, List[str]]:
        """one stop generation function

        Args:
            file (io.BufferedReader): file

        Returns:
            List[str]: image links
        """

        _, prompts = self.generate_prompts(file)
        
        res = dict()
        for idx, p in enumerate(prompts):
            res[idx] = self.generate_image(p)

        return res
    

if __name__ == '__main__':

    backend = Assistant()
    # load data
    # file = open(DATA / "Menti Export Output.xlsx", "rb")
    # code, proposal, prompts = backend.generate_prompts(file)
    # code = 'import pandas as pd\n\n# Load the Excel file\nfile_path = \'/mnt/data/file-HMpb7inTRCATuklEXPQxLfdt\'\nxls = pd.ExcelFile(file_path)\n\n# Display sheet names to identify the last sheet\nsheet_names = xls.sheet_names\nsheet_names\n# Load the last sheet\ndf = pd.read_excel(xls, sheet_name=\'Session 2\')\n\n# Display the first few rows to understand its structure\ndf.head()\n# Search for the row containing the word "Upvotes"\nupvotes_row = df[df.isin([\'Upvotes\']).any(axis=1)].index[0]\n\n# Extract dataset_2 by discarding all rows from 1 to upvotes_row-1\ndataset_2 = df.iloc[upvotes_row:]\n\n# Reset the index and rename columns\ndataset_2.columns = dataset_2.iloc[0]\ndataset_2 = dataset_2[1:].reset_index(drop=True)\n\n# Display the first few rows of dataset_2\ndataset_2.head()\n# Duplicate the responses according to their upvote counts\ndataset_2[\'Upvotes\'] = dataset_2[\'Upvotes\'].astype(int)\ndataset_3 = dataset_2.loc[dataset_2.index.repeat(dataset_2[\'Upvotes\'])]\n\n# Remove the "Upvotes" column\ndataset_3 = dataset_3.drop(columns=[\'Upvotes\']).reset_index(drop=True)\n\n# Display the first few rows of dataset_3\ndataset_3.head()\nfrom sklearn.feature_extraction.text import CountVectorizer\nfrom sklearn.decomposition import LatentDirichletAllocation\n\n# Extract the responses\nresponses = dataset_3[\'Responses\'].tolist()\n\n# Vectorize the text data\nvectorizer = CountVectorizer(stop_words=\'english\')\nX = vectorizer.fit_transform(responses)\n\n# Apply LDA for topic modeling\nlda = LatentDirichletAllocation(n_components=3, random_state=42)\nlda.fit(X)\n\n# Get the topics and the top words for each topic\ndef get_topics(model, feature_names, n_top_words):\n    topics = []\n    for topic_idx, topic in enumerate(model.components_):\n        top_features_ind = topic.argsort()[:-n_top_words - 1:-1]\n        top_features = [feature_names[i] for i in top_features_ind]\n        topics.append(top_features)\n    return topics\n\nn_top_words = 10\nfeature_names = vectorizer.get_feature_names_out()\ntopics = get_topics(lda, feature_names, n_top_words)\n\ntopics'

    prompts = ['A vibrant, affordable housing complex in Singapore with pet-friendly areas, giant cats sculptures, colourful family parks, and lush green spaces', 'A lush, well-shaded recreational area in Singapore with running tracks, sheltered walkways, rest areas, and vibrant play spaces promoting work-life balance', 'An open park in Singapore with shaded areas for exercise, cycling paths, and facilities for various outdoor activities, promoting a healthy lifestyle']

    res = backend.generate_image(prompts[0])
    
    logger.info("completed")
